\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{xcolor, colortbl}
\begin{document}

\section{Introduction}

Le TP consistait à réaliser, en utilisant Ocaml et les librairies LLVM, un compilateur pour le 
langage VSL+ afin de générer du code 3 adresses. Plus précisément, on devait réaliser la 
vérification de type ainsi que la génération de code à partir d'un AST. En effet les analyseurs lexical 
et syntaxique de VSL+ étaient déjà fournis (c'est eux qui produisent la représentation sous forme 
d'AST d'un programme VSL+).

\section{Méthodologie de travail}

La majeure partie du travail a été effectué en TP  à deux sur le même
ordinateur. Pour ce qui est du code écrit hors TP, Nicolas Pompidor s'est chargé
des expressions simples et d'une partie des structures de contrôle tandis que
Rémy Sun a écrit le code de gestion des fonctions et de gestion des tableaux.

Pour l'organisation du code, il y a été créé dans codegen.ml une fonction par type dans 
l'ast.ml. Et c'est dans codegen.ml qu'a été écrit l'ensemble du code.
Pour les tests, nous en avons créé pour chaque nouvelle fonctionnalité du compilateur. Puis, 
quand ceux-ci furent fonctionnels, nous avons exécutés les tests fournis.

L'ensemble des tests proposés dans le fichier de test ont été passés avec
optimisation, à l'exception de \texttt{level4testfact.vsl}. En effet, il
semblerait que si la seule instruction dans le else est un RETURN,
l'optimisateur décide d'éliminer le bloc (comportement illicite).

\section{Ce qui a été réalisé}

\paragraph{Les expressions simples}
Complètement réalisé.
Nous avons repris la structure pour l'addition et on l'a appliqué pour les autres expressions.
 
\paragraph{L'instruction d'affectation}
 Complètement réalisé.
On stocke la valeur grâce à \texttt{Llvm.build\_store} et on retient
l'emplacement Llvm par un lien symbolique au nom de variable déclaré.

\paragraph{La gestion des blocs}
Complètement réalisé.
Ouverture d'un scope au début du bloc, on réalise la déclaration puis le statement et on ferme le 
scope.

\paragraph{La declaration des variables}
Complètement réalisé.

\paragraph{Les expressions avec variables}
Complètement réalisé

\paragraph{Les instructions de contrôle }
Complètement réalisé.
On créer un bloc pour le if où on évalue la condition puis soit on se branche sur le block du ''then'' 
ou alors du ''else'' puis ces deux blocs se branchent sur le ''eblock'' à la
fin. Une instruction phi est mis en place par l'optimisateur pour gérer le
branchement sur le bloc de fin.

\paragraph{La definition et l'appel de fonctions (avec les prototypes)}
Complètement réalisé.


\paragraph{Les fonctions de la bibliotheque}
Complètement réalisé


\paragraph{La gestion des tableaux (declaration, expression, affectation et
  lecture)} 
Complètement réalisé

\section{Tests}

\subsection{Level 1}

L'ensemble des tests du niveau 1 ont été passés sans encombre notable

\subsection{Level 2}

L'ensemble des tests du niveau 2 ont été passés sans encombre notable

\subsection{Level 3}

L'ensemble des tests du niveau 3 ont été passés sans encombre notable

\subsection{Level 4}

L'ensemble des tests du niveau 4 ont été passés sans encombre notable à
l'exception de deux programmes de test: \texttt{level4divergence.vsl} et
\texttt{level4testfact.vsl}

\paragraph{level4divergence}

Ce programme imprime Toto puis lance une boucle infinie. Néanmoins, à
l'exécution du programme rien n'est imprimé. Cela s'explique assez simplement:
Notre implémentation de printf n'est jamais qu'un appel à la fonction
\texttt{printf} de C! Hors cette fonction n'imprime pas immédiatement le message
demandé. Si ce message n'est pas de taille ``suffisante'' et ne contient pas de
caractére indiquant à la fonction d'imprimer, le message est mis en attente dans
un buffer. Hors notre programme ne s'arrête jamais, et n'a jamais de raison de
vider son buffer. Ainsi, rien n'est imprimé! On vérifie bien qu'en imprimant
``Toto$\backslash$n'' à la place de ``Toto'', le message est bien imprimé. \textcolor{blue}{Le
  test fonctionne bien}

\paragraph{level4testfact}

Ce programme s'exécute bien sur le code non optimisé généré. Néanmoins, cela
n'est pas le cas si on regarde le code optimisé. En effet, il y a un branchemnt
IF effectuée, et la seule instruction dans la branche ELSE est un RETURN 1. Hors
il semblerait que l'optimisateur pense possible de supprimer ce bloc, ce qui
entraîne un problême de comportement.

\subsection{Test proposé}

Nous avons écris un fichier un fichier de test \texttt{myTest.vsl} qui nous
semble couvrir les principaux points importants à tester.

Les fonctionnalités couvertes sont:
\begin{itemize}
\item Calcul d'expressions simples
\item Structure de contrôle
\item Prototypes et fonctions
\item 
\end{itemize}

\end{document}
